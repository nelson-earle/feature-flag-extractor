import { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';
import { JsonObject } from '@angular-devkit/core';
import * as fs from 'fs';
import * as path from 'path';
import * as ts from 'typescript';
import { parseTemplate } from '@angular/compiler';

interface Options extends JsonObject {
}

export default createBuilder<Options>(templateLoggerBuilder);

async function templateLoggerBuilder(
    options: Options,
    context: BuilderContext
): Promise<BuilderOutput> {
    try {
        context.logger.info('üîç Starting template logger builder...');

        // Get the workspace root
        const workspaceRoot = context.workspaceRoot;

        // Get the project name and config
        const projectName = context.target?.project || '';
        if (!projectName) {
            throw new Error('No project specified');
        }

        const projectMetadata = await context.getProjectMetadata(projectName);
        const sourceRoot = projectMetadata.sourceRoot as string;
        const projectRoot = path.join(workspaceRoot, sourceRoot);

        context.logger.info(`üìÅ Scanning project: ${projectName} at ${projectRoot}`);

        // Scan for components and log their templates
        const componentFiles = await findComponentFiles(projectRoot);
        context.logger.info(`üîé Found ${componentFiles.length} potential component files`);

        // Process each component file
        for (const file of componentFiles) {
            processComponentFile(file, context);
        }

        return { success: true };
    } catch (error) {
        context.logger.error('‚ùå Error in template logger builder: ' + (error as Error).message);
        return { success: false, error: (error as Error).message };
    }
}

/**
 * Recursively find all TypeScript files that might be components
 */
async function findComponentFiles(directoryPath: string): Promise<string[]> {
    const files: string[] = [];

    const entries = fs.readdirSync(directoryPath, { withFileTypes: true });

    for (const entry of entries) {
        const fullPath = path.join(directoryPath, entry.name);

        if (entry.isDirectory()) {
            // Skip node_modules and other common non-source directories
            if (entry.name !== 'node_modules' && 
                entry.name !== 'dist' && 
                entry.name !== '.git' &&
                !entry.name.startsWith('.')) {
                const subDirFiles = await findComponentFiles(fullPath);
                files.push(...subDirFiles);
            }
        } else if (entry.isFile() && 
            (entry.name.endsWith('.component.ts') || 
                entry.name.endsWith('.ts'))) {
            files.push(fullPath);
        }
    }

    return files;
}

/**
 * Process a component file to extract and log templates
 */
function processComponentFile(filePath: string, context: BuilderContext): void {
    try {
        // Read the file content
        const fileContent = fs.readFileSync(filePath, 'utf-8');

        // Parse the TypeScript file
        const sourceFile = ts.createSourceFile(
            filePath,
            fileContent,
            ts.ScriptTarget.Latest,
            true
        );

        // Find Component decorators
        visitNode(sourceFile);

        function visitNode(node: ts.Node) {
            // Look for @Component decorators
            if (ts.isDecorator(node) && 
                ts.isCallExpression(node.expression) && 
                ts.isIdentifier(node.expression.expression) &&
                node.expression.expression.text === 'Component') {

                // Extract the component decorator argument
                const decoratorArg = node.expression.arguments[0];
                if (decoratorArg && ts.isObjectLiteralExpression(decoratorArg)) {
                    const componentProperties = decoratorArg.properties;

                    // Variables to hold template information
                    let inlineTemplate: string | undefined;
                    let templateUrl: string | undefined;

                    // Extract template or templateUrl
                    for (const prop of componentProperties) {
                        if (ts.isPropertyAssignment(prop)) {
                            const propName = prop.name.getText(sourceFile);

                            if (propName === 'template') {
                                if (ts.isStringLiteral(prop.initializer) || ts.isNoSubstitutionTemplateLiteral(prop.initializer)) {
                                    inlineTemplate = prop.initializer.getText(sourceFile);
                                    // Remove quotes or backticks
                                    inlineTemplate = inlineTemplate.substring(1, inlineTemplate.length - 1);
                                    processTemplate(inlineTemplate, filePath, 'inline', context);
                                }
                            } else if (propName === 'templateUrl') {
                                if (ts.isStringLiteral(prop.initializer)) {
                                    templateUrl = prop.initializer.getText(sourceFile);
                                    // Remove quotes
                                    templateUrl = templateUrl.substring(1, templateUrl.length - 1);
                                    processExternalTemplate(templateUrl, filePath, context);
                                }
                            }
                        }
                    }
                }
            }

            // Continue recursively checking all nodes
            ts.forEachChild(node, visitNode);
        }
    } catch (error) {
        context.logger.error(`‚ùå Error processing file ${filePath}: ${(error as Error).message}`);
    }
}

/**
 * Process an inline template
 */
function processTemplate(template: string, filePath: string, type: 'inline' | 'external', context: BuilderContext): void {
    try {
        // Parse the template using Angular's compiler
        const parsedTemplate = parseTemplate(template, filePath);

        // Log template info
        context.logger.info(`‚úÖ Found ${type} template in ${filePath}`);
        context.logger.info(`Template content: ${template.substring(0, 100)}${template.length > 100 ? '...' : ''}`);

        // You can access the AST nodes like this:
        // parsedTemplate.nodes.forEach(node => {
        //   // Process nodes as needed
        // });
    } catch (error) {
        context.logger.error(`‚ùå Error parsing template in ${filePath}: ${(error as Error).message}`);
    }
}

/**
 * Process an external template file
 */
function processExternalTemplate(templateUrl: string, componentFilePath: string, context: BuilderContext): void {
    try {
        // Resolve the template path relative to the component
        const componentDir = path.dirname(componentFilePath);
        const templatePath = path.resolve(componentDir, templateUrl);

        // Check if template file exists
        if (fs.existsSync(templatePath)) {
            const templateContent = fs.readFileSync(templatePath, 'utf-8');
            processTemplate(templateContent, templatePath, 'external', context);
        } else {
            context.logger.warn(`‚ö†Ô∏è External template not found: ${templatePath}`);
        }
    } catch (error) {
        context.logger.error(`‚ùå Error processing external template ${templateUrl}: ${(error as Error).message}`);
    }
}
